<?php
require_once('config.php');
$run = 32;
//$limit = 25;
$cvePath = '../ossf-cve-benchmark/CVEs/';
$sourceDir = '../ossf-cve-benchmark2/work/sources';
$dir = new DirectoryIterator($cvePath);
$model = 'gpt-3.5-turbo';
//$model = 'gpt-4-turbo-2024-04-09';
$overwrite = true;
$log = '';
$preCount = 0;
$postCount = 0;
$postCount = 0;
$preCountAll = 0;
$notFound = 0;
$promptLog = '';
$errors = [];
$totalFiles = 0;

$preYes = 0;
$postNo = 0;
$specificCVE = false;
//$specificCVE = 'CVE-2020-26226';
$headers = ['CVE', 'repo', 'preCommit', 'file', 'truth_line', 'truth_snippet', 'line', 'snippet', 'type', 'explanation', 'CWE'];
$time = time();
$d = new DateTime('now');
$d->setTimezone(new DateTimeZone('EST'));
$time = $d->format('Y-m-d-H:i:s');

setupDirs($time, $run);

//Spreadsheet of all vulnerabilities found
$prePatchResultsFile = fopen("results/$time/prePatch-all-$time.csv", 'w');
$postPatchResultsFile = fopen("results/$time/postPatch-all-$time.csv", 'w');

//Spreadsheet of only vulnerabilities that match truth
$prePatchResultsFile2 = fopen("results/$time/prePatch$time.csv", 'w');
$postPatchResultsFile2 = fopen("results/$time/postPatch-$time.csv", 'w');

$truthCSVFile = fopen("results/$time/truth.csv", 'w');
fputcsv($prePatchResultsFile, $headers, ',');
fputcsv($postPatchResultsFile, $headers, ',');
fputcsv($prePatchResultsFile2, $headers, ',');
fputcsv($postPatchResultsFile2, $headers, ',');
fputcsv($truthCSVFile, $headers, ',');


$auth = "Authorization: Bearer $secret";
$ch = curl_init("https://api.openai.com/v1/chat/completions");
curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json', $auth));
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$post = ['model' => $model];
$post['temperature'] = 0.7;

//CVEs that exceed token limits
$skipArray = ['CVE-2020-8203', 'CVE-2019-10767', 'CVE-2018-3721', 'CVE-2019-16763', 'CVE-2019-14772', 'CVE-2019-13127', 'CVE-2021-23344', 'CVE-2019-10744'];
$processedCount = 0;
foreach ($dir as $fileinfo) {
    if (!$fileinfo->isDot()) {
        $fileName = $fileinfo->getFilename();
        if ($specificCVE)
            $fileName = $specificCVE . '.json';
        $cveJSON = json_decode(file_get_contents($cvePath . $fileName));
        $cve = $cveJSON->CVE;

        if (in_array($cve, $skipArray))
            continue;

        $repo = $cveJSON->repository;
        $prePatch = $cveJSON->prePatch->commit;
        $prePatchSource = $sourceDir . '/' . $cve . '/' . $prePatch;

        $postPatch = $cveJSON->postPatch->commit;
        $postPatchSource = $sourceDir . '/' . $cve . '/' . $postPatch;

        if (!file_exists($prePatchSource)) {
            mkdir($sourceDir . '/' . $cve);
            if (exec("git clone $repo $prePatchSource && cd repos/$prePatch && git checkout $prePatch", $output, $result) !== 0) {
                writeLog($cve . ' - ' . $output);
            }
        }
        if (!file_exists($postPatchSource)) {
            mkdir($sourceDir . '/' . $cve);
            if (exec("git clone $repo $postPatchSource && cd repos/$postPatch && git checkout $postPatch", $output, $result) !== 0) {
                writeLog($cve . ' - ' . $output);
            }
        }
        echo "\n$cve \n";
        $weaknesses = $cveJSON->prePatch->weaknesses;
        foreach ($weaknesses as $index => $weakness) {
            $file = $weakness->location->file;
            $line = $weakness->location->line;
            $truthSnippet = getSnippetFromLineNumber($line, $prePatchSource . '/' . $file);
            $explanation = $weakness->explanation;
            if (runPromptOnFile($prePatchSource, $file, $prePatch, $ch, $post, $prePatchResultsFile, $prePatchResultsFile2, 'pre')) {
                curl_close($ch);
                $ch = curl_init("https://api.openai.com/v1/chat/completions");
                curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json', $auth));
                curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
                curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
                $totalFiles++;
                //only add weakness to truth file if we were able to process it (i.e to exclude files that exceed token limit)
                $truthCSV = [$cve, $repo, $prePatch, $file, $line, $truthSnippet, '', '', $explanation, implode(",", $cveJSON->CWEs)];
                fputcsv($truthCSVFile, $truthCSV, ',');

                runPromptOnFile($postPatchSource, $file, $postPatch, $ch, $post, $postPatchResultsFile, $postPatchResultsFile2, 'post');

            }


        }
        $processedCount++;

        echo "processed  $processedCount so far\n";
        echo "Matching vulnerabilities pre vs post: $preCount vs. $postCount\n";
        echo "Total vulnerabilities detected: $preCountAll \n";
        echo "Total snippets not found in the file: $notFound \n";


        if (!empty($limit)) {
            if ($processedCount >= $limit) {
                break;
            }
        }

        if ($specificCVE)
            break;
    }
}

fclose($prePatchResultsFile);
fclose($postPatchResultsFile);
fclose($truthCSVFile);

if ($log) {
    var_dump($log);
}
$end = new DateTime('now');
$end->setTimezone(new DateTimeZone('EST'));
$interval = $end->diff($d);

$totaltime = $interval->format('%H:%i:%s');
echo "start: $time \n";
echo 'Total time: ' . $totaltime;
echo "\nMatching vulnerabilities pre vs post: $preCount vs. $postCount";
echo 'Total vulnerabilities detected: ' . $preCountAll;
echo "Post Patches with no vulnerability detected: $postNo \n";
echo "Pre Patches with vulnerabilities detected: $preYes; \n";
echo "Total files: $totalFiles; \n";

file_put_contents('output/' . $run . '/prompt-' . $time . '.txt', $promptLog);
file_put_contents('results/' . $time . '/log.txt', print_r($errors, true));
file_put_contents('results/' . $time . '/prompt.txt', $post);

/**
 * Template format that we want the response in
 * @return array[]
 */


function runPrompt($sourceFile, $outputFile, $ch, $overwrite)
{
    global $cve, $file;
    $filesize = filesize($sourceFile);
    //max for gpt-3.5 is 16,000 tokens = 64,000 bytes~
    if ($filesize > 64000) {
        $filesize = $filesize / 1000;
        $result = 'File too large: ' . $filesize . 'KB';
        addError(['cve' => $cve, 'file' => $file, 'error' => $result]);
        //file_put_contents($outputFile . '-error', $result);
        return false;
    } else if (!file_exists($outputFile) || $overwrite) {
        $result = curl_exec($ch);
        file_put_contents($outputFile, $result);
    } else {
        $result = file_get_contents($outputFile);
    }

    return $result;
}

function writeLog($msg)
{
    global $log;
    $log .= $msg . "\n";
}

function calculateLineNumber($lineNum, $file, $snippet)
{
    $lines = file($file);
    $snippetLineNum = false;
    $snippetLines = explode(PHP_EOL, $snippet);
    $lineCount = count($snippetLines);
    $tempLine = 0;
    if (strpos($snippetLines[0], "...") !== false) {
        $snippetLines[0] = substr($snippetLines[0], 0, strpos($snippetLines[0], "..."));
    }
    $snippetLines[0] = strtok($snippetLines[0], '{');

    foreach ($lines as $key => $line) {
        $line = trim($line, ':'); //Sometimes GPT adds a colon before presenting the code snippet
        $snippetLineNum = (strpos(trim($line), trim($snippetLines[0])) !== FALSE) ? $key + 1 : $snippetLineNum;
        if (!$snippetLineNum) { //try comparing without spaces
            $snippetLineNum = (strpos(str_replace(' ', '', trim($line)), str_replace(' ', '', trim($snippetLines[0]))) !== FALSE) ? $key + 1 : $snippetLineNum;
        }
        if (!$snippetLineNum) {
            //sometimes GPT converts literal \t in regexes to actual tab characters in snippet so we need to convert it back. (Indentation tabs already get trimmed before comparison)
            $literalTabCharacter = str_replace("\t", '\t', trim($snippetLines[0]));
            $snippetLineNum = (strpos(str_replace(' ', '', trim($line)), str_replace(' ', '', trim($literalTabCharacter))) !== FALSE) ? $key + 1 : $snippetLineNum;
        }

        if ($snippetLineNum) {
            echo $snippetLines[0];
            if ($snippetLineNum == $lineNum)
                return $snippetLineNum;
            else if (($lineNum >= $snippetLineNum) && ($lineNum <= ($snippetLineNum + $lineCount))) { //if the snippet is multi-line and the vulnerable line is contained within one of those lines
                return $lineNum;
            } else {
                $tempLine = $snippetLineNum;
                $snippetLineNum = false;
            }
        }
    }

    return $tempLine;
}

function getSnippetFromLineNumber($lineNumber, $file)
{
    $lines = file($file);
    return $lines[$lineNumber - 1];
}

function setupDirs($time, $run)
{
    if (!file_exists('results')) {
        mkdir('results');
    }
    mkdir("results/$time");

    if (!file_exists('output')) {
        mkdir('output');
    }
    if (!file_exists('output/' . $run)) {
        mkdir('output/' . $run);
    }
}


function basePrompt($source, $file, $commitHash, $ch, $post, $resultsFile, $resultsFile2, $type)
{
    $promptLog = [];
    $flaggedPre = [];
    $flaggedPost = [];
    $return = false;
    $fileContent = file_get_contents($source . '/' . $file);
    if (!$fileContent) {
        echo 'File not found: ' . $source . '/' . $file . "\n";
        return false;
    } else {
        $fileContent = removeComments($fileContent);
    }
    global $cve, $repo, $line, $preCount, $truthSnippet, $postCount, $preCountAll, $notFound, $preYes, $postNo;

    $post['messages'] = []; //reset
    $post['messages'][] = ['role' => 'system', 'content' => 'You are a software security analysis tool designed to detect vulnerabilities in code.'];
    $post['response_format'] = ['type' => 'json_object'];
    $tempPost = $post;
    echo $type . " \n";

    // print_r($reply);
    $post['temperature'] = 0.7;
    //$prompt = "Are there any security vulnerabilities in the code below? Answer yes if there are any vulnerabilities or no if there are no vulnerabilities. Answer in one word. Here is the code:";  //;// Answer yes if there are any vulnerabilities or no if there are no vulnerabilities.

    //  $post['messages'][] = ['role' => 'user', 'content' => $prompt . "\n" . $fileContent];
    //  $post['messages'][] = ['role' => 'assistant', 'content' => 'Yes'];
    //   $post['messages'][] = ['role' => 'user', 'content' => 'Check the code for security vulnerabilities and list all the vulnerability types found in the code. Answer in JSON format like this: { "vulnerability_types" :[] }'];
    $prompt = 'Are there any Common Weakness Enumerations or security vulnerabilities in the code? If yes, show the code snippet for each vulnerability and include the Common Weakness Enumeration (CWE) for each vulnerability. Keep the code in its original format with all original line endings included. Answer in JSON format like this: { "vulnerabilities" :[ {"description": "description of the vulnerability", "codeSnippet":"lines of code with the vulnerability", "cwe":"CWE ID of the vulnerability e.g CWE-036"} ] } . If there are no vulnerabilities, return an empty array.';
    $post['messages'][] = ['role' => 'user', 'content' => $prompt . "\n" . $fileContent];

    $reply = runPromptAndProcessResponse($ch, $post);
    if (!$reply)
        return false;

    $vulnerabilities = json_decode($reply, true);
    $count = 0;
    if (!empty($vulnerabilities['vulnerabilities']) && is_array($vulnerabilities['vulnerabilities'])) {
        $vulnerabilities = $vulnerabilities['vulnerabilities'];
        $count = count($vulnerabilities);
    } else {
        print_r($reply);
        echo "ISSUE with $cve \n";
    }
    echo $count;
    if ($count == 0) {
        if ($type == 'post')
            $postNo++;
        echo "vulnerability count was 0 \n";
        print_r($reply);
        $vulnerabilities = false;
    } else if ($type == 'pre') {
        $preYes++;
    }


    if ($count > 0) {
        //  $post['messages'][] = ['role' => 'assistant', 'content' => $reply];
        //   $post['messages'][] = ['role' => 'user', 'content' => 'For each of the ' . $count . ' vulnerabilities mentioned, show the line(s) of code with the vulnerability and explain why it is vulnerable. Keep the code in its original format with all original line endings included. Answer in JSON format with fields description and codeSnippet.']; //.'Match each of the '.$count.' vulnerability types to their related CWEs. Each vulnerability may be associated with one or more CWE. Answer in JSON format with fields type, CWE and codeSnippet.'];
        //   $reply = runPromptAndProcessResponse($ch, $post, false);
        //   $vulnerabilities = json_decode($reply, true);
        //     $vulnerabilities = $types['vulnerabilities'];


        if (!empty($vulnerabilities)) {
            echo $type . "\n";
            foreach ($vulnerabilities as $vulnerability) {
                $codeSnippet = $vulnerability['codeSnippet'];
                if (!is_string($codeSnippet)) {
                    echo 'CODE SNIPPET NOT A STRING';
                    print_r($codeSnippet);
                    continue;
                }
                $vulnerability['CWE'] = $vulnerability['cwe'];
                $lineNum = calculateLineNumber($line, $source . '/' . $file, $codeSnippet);
                if ($lineNum == 0)
                    $notFound++;
                echo $vulnerability['description'] . ' - ' . $lineNum . ' vs. ' . $line . ' - ' . $type . "\n";

                echo 'snippet: ' . $codeSnippet . "\n";
                if ($type == 'pre')
                    echo 'truth: ' . getSnippetFromLineNumber($line, $source . '/' . $file);
                echo $source . '/' . $file . "\n\n";

                if ($type == 'pre') {
                    if (isset($flaggedPre[$lineNum]))
                        continue;
                    else
                        $flaggedPre[$lineNum] = 1;
                }

                if ($type == 'post') {
                    if (isset($flaggedPost[$lineNum]))
                        continue;
                    else
                        $flaggedPost[$lineNum] = 1;
                }

                $record = [$cve, $repo, $commitHash, $file, $line, $truthSnippet, $lineNum, $codeSnippet, 'type', $vulnerability['description'], $vulnerability['cwe']];

                if (!fputcsv($resultsFile, $record, ',')) {
                    echo "ERROR with CSV";
                    exit;
                }
                if ($type == 'pre') {
                    $preCountAll++;
                }

                if ($lineNum == $line) {
                    if ($type == 'pre')
                        $preCount++;
                    else
                        $postCount++;
                    fputcsv($resultsFile2, $record, ',');
                }


            }
        }
    }

    global $time, $line;
    $promptLog = $post;
    $promptLog['TYPE'] = $type;
    $promptLog['CVE'] = $cve;
    $promptLog['line'] = $line;
    $promptLog['prompt'] = $prompt;
    $promptLog['messages'][1] = $source . '/' . $file;
    $promptLog['messages'][] = $reply;
    file_put_contents('logs/' . $time . '.txt', print_r($promptLog, true), FILE_APPEND);
    return true;

}

function runPromptOnFile($source, $file, $commitHash, $ch, $post, $resultsFile, $resultsFile2, $type)
{
    // return basePrompt($source, $file, $commitHash, $ch, $post, $resultsFile, $resultsFile2, $type);
    $promptLog = [];
    $flaggedPre = [];
    $flaggedPost = [];
    $fileContent = file_get_contents($source . '/' . $file);
    if (!$fileContent) {
        echo 'File not found: ' . $source . '/' . $file . "\n";
        return false;
    } else {
        $fileContent = removeComments($fileContent);
    }
    global $cve, $repo, $line, $preCount, $truthSnippet, $postCount, $preCountAll, $notFound, $preYes;

    $post['messages'] = []; //reset
    $post['messages'][] = ['role' => 'system', 'content' => 'You are a software security analysis tool designed to detect vulnerabilities in code.'];
    $vulnerableCount = 0;
    $nonSafeCount = 0;
    $post['temperature'] = 0.7;
    echo $type . " \n";
    $template = '{ "vulnerabilities" :[ {"description": "description of the vulnerability", "codeSnippet":"the snippet of code with the vulnerability", "cwe":"CWE ID for each vulnerability} ] }';
    //addChainOfThoughtPrompts($post, $template);

    $tempPost = $post;

    for ($i = 0; $i < 1; $i++) {
        $prompt = "Are there any security vulnerabilities in the code? Answer yes or no. Do not elaborate. Here is the code:";  //;// Answer yes if there are any vulnerabilities or no if there are no vulnerabilities.

        $post['messages'][] = ['role' => 'user', 'content' => $prompt . "\n" . $fileContent];
        $reply = runPromptAndProcessResponse($ch, $post, false);

        if ($reply) {
            $firstWord = explode(' ', $reply);
            $firstWordcomma = explode(',', $reply);
            $firstWordPeriod = explode('.', $reply);


            if (strtolower($firstWord[0]) == 'yes' || strtolower($firstWordcomma[0]) == 'yes' || strtolower($firstWordPeriod[0]) == 'yes') {
                $vulnerableCount++;
            } else if (strtolower($firstWord[0]) != 'no' && strtolower($firstWordcomma[0]) != 'no' && strtolower($firstWordPeriod[0]) != 'no') {
                echo "Unexpected response format: $reply \n";
            }
        } else {
            return false;
        }
        $post = $tempPost; //reset
    }
    echo "-----\n";

    if (false && $vulnerableCount < 4) {
        for ($i = 0; $i < 4; $i++) {
            //  echo "Inside forloop ... $i \n";
            // $prompt = "Are there any security vulnerabilities in the code below? Answer in JSON format like this: {'answer':'yes or no' } . Here is the code:";  //;// Answer yes if there are any vulnerabilities or no if there are no vulnerabilities.
            $prompt = "Is this code free of security vulnerabilities? Answer yes or no. Do not elaborate. Here is the code:";
            $post['messages'][] = ['role' => 'user', 'content' => $prompt . "\n" . $fileContent];
            $reply = runPromptAndProcessResponse($ch, $post, false);
            if ($reply === false) {
                $post = $tempPost;
                break;
            }

            if ($reply) {
                $firstWord = explode(' ', $reply);
                $firstWordcomma = explode(',', $reply);
                $firstWordPeriod = explode('.', $reply);

                if (strtolower($firstWord[0]) == 'no' || strtolower($firstWordcomma[0]) == 'no' || strtolower($firstWordPeriod[0]) == 'no') {
                    $nonSafeCount++;
                } else if (strtolower($firstWord[0]) != 'yes' && strtolower($firstWordcomma[0]) != 'yes' && strtolower($firstWordPeriod[0]) != 'yes') {
                    echo "Unexpected response format (2): $reply \n";
                }
            }
            $post = $tempPost; //reset
        }
    } else {
        $nonSafeCount = 'n/a';
    }
    if ($type == 'pre') {
        echo "Number of vulnerable pre: $vulnerableCount \n";
        echo "Number of non-safe pre: $nonSafeCount \n";
    } else {
        echo "Number of vulnerable post: $vulnerableCount \n";
        echo "Number of non-safe post: $nonSafeCount \n";
    }
    $post['temperature'] = 0.7;
    $post = $tempPost;
    if ($vulnerableCount > 0) { // || ($vulnerableCountPre >= 3 && $nonSafeCountPre >=3)) || ($vulnerableCountPost >=4  || $nonSafeCountPost >= 4 || ($vulnerableCountPost >= 3 && $nonSafeCountPost >= 3)) ){
        if ($type == 'pre') {
            $preYes++;
        }

        echo "Number of files with a vulnerability so far: $preYes \n";

        $prompt = "Are there any security vulnerabilities in the code? Answer yes or no. Here is the code: ";
        $post['messages'][] = ['role' => 'user', 'content' => $prompt . "\n" . $fileContent];
        $post['messages'][] = ['role' => 'assistant', 'content' => 'Yes.'];
        $prompt = 'Find all the security vulnerabilities or weaknesses in the code. For each vulnerability, show the lines of code with the vulnerability and briefly explain why it is vulnerable. Keep the code in its original format with all original line endings included. Determine the Common Weakness Enumeration (CWE) of each vulnerability and include it in the response. Answer in JSON format like this: { "vulnerabilities" :[ {"description": "description of the vulnerability", "codeSnippet":"lines of code with the vulnerability", "cwe":"CWE ID of the vulnerability e.g CWE-036"} ] }  ';

        //$prompt = 'Find the security vulnerabilities in the code. Give a very brief description of the vulnerability and show the code snippet or lines of code with the vulnerability. Keep the code in its original format with all original line endings included. Here is the code: ';
        $post['messages'][] = ['role' => 'user', 'content' => $prompt];

//        $reply = runPromptAndProcessResponse($ch, $post);
//
//        if ($reply) {
//            $post['messages'][] = ['role' => 'assistant', 'content' => $reply];
//        } else
//            return false;
//        $post['temperature'] = 0.5;
//        $post['messages'][] = ['role' => 'user', 'content' => 'Reformat your response in JSON format and determine the Common Weakness Enumeration or CWE for each vulnerability. Answer in JSON format like this: ' . $template];
//
//        $post['messages'][] = ['role' => 'user', 'content' => 'Reformat your response as a JSON array and include the code snippet of each vulnerability. For the code snippets, show the lines exactly as they are in the original code and include all original line endings. Answer in JSON format like this: ' . $template];
//        $post['messages'][] = ['role' => 'user', 'content' => 'List the Common Weaknesses found in the code. Answer in JSON format like this: { "vulnerability_types" :[ {"cwe": "the CWE ID of the vulnerability" } ] }'];
//
//        $post['messages'][] = ['role' => 'user', 'content' => 'List all security vulnerability types or Common Weaknesses found in the code. Answer in JSON format like this: { "vulnerability_types" :[ {"cwe": "the CWE ID of the vulnerability" } ] }'];
//        $post['messages'][] = ['role' => 'user', 'content' => 'List all security vulnerabilities found in the code and show the code snippet(s) for each. Keep the code snippets in their original, unaltered format and include all original line endings. State the Common Weakness Enumeration for each vulnerability. Answer in JSON format like this: { "vulnerabilities" :[ {"description": "description of the vulnerability", "codeSnippet":"lines of code with the vulnerability", "cwe":"CWE ID of the vulnerability e.g CWE-036"} ] }'];
//
//        $post['response_format'] = ['type' => 'json_object'];
//
//        echo "Number found: $reply \n";
//        $post['messages'][] = ['role' => 'assistant', 'content' => $reply];
//
//        $numFound = 0;
//        if (preg_match('/(\d+)/', $reply, $matches)) {
//            $numFound = $matches[1];
//        }

        $reply = runPromptAndProcessResponse($ch, $post);
        if (!$reply) {
            return false;
        }
        $vulnerabilities = json_decode($reply, true);
        $count = 0;

        if (!empty($vulnerabilities['vulnerabilities'])) {
            $vulnerabilities = $vulnerabilities['vulnerabilities'];
            $count = count($vulnerabilities);
        } else {
            echo "PROBLEM";
        }


//            if(!empty($types['vulnerability_types']) && is_array($types['vulnerability_types'])) {
//                $types = $types['vulnerability_types'] ;
//                $count = count($types);
//               // $vulnerabilities = $types;
//            }

        echo $count;
        if ($count == 0) {
            echo "vulnerability count was 0 \n";
            print_r($reply);
            $vulnerabilities = false;
        }


//        if ($count > 1) {
//        } else {
//            $post['messages'][] = ['role' => 'user', 'content' => 'Show the code snippet of the vulnerability. Keep the code in its original format with all original line endings and spaces included. Answer in JSON format like this: { "vulnerabilities" :[ { "description": "description of the vulnerability", "codeSnippet":"lines of code with the vulnerability", "cwe":"CWE ID of the vulnerability e.g CWE-036"} ] }'];
//        }


        if ($count > 0) {
//            $post['messages'][] = ['role' => 'assistant', 'content' => $reply];
//            $post['messages'][] = ['role' => 'user', 'content' => 'For each Common Weakness Enumeration found, show all code snippets with that weakness/vulnerability. Keep the code snippets in their original, unaltered format and include all original line endings. Answer in JSON format like this: { "vulnerabilities" :[ {"description": "description of the vulnerability", "codeSnippet":"lines of code with the vulnerability", "cwe":"CWE ID of the vulnerability e.g CWE-036"} ] }'];
//
//            $reply = runPromptAndProcessResponse($ch, $post);
//            if (!$reply) {
//                return false;
//            }
//            $vulnerabilities = json_decode($reply, true);
//            $post['messages'][] = ['role' => 'assistant', 'content' => $reply];
//            $post['messages'][] = ['role' => 'user', 'content' => 'For each of the ' . $count . ' vulnerabilities mentioned, show the line(s) of code with the vulnerability and explain why it is vulnerable. Keep the code in its original format with all original line endings included. Answer in JSON format with fields description and codeSnippet.']; //.'Match each of the '.$count.' vulnerability types to their related CWEs. Each vulnerability may be associated with one or more CWE. Answer in JSON format with fields type, CWE and codeSnippet.'];
//            $reply = runPromptAndProcessResponse($ch, $post, false);
//            $vulnerabilities = json_decode($reply, true);
//
//            $vulnerabilities = $types['vulnerabilities'];


            if (!empty($vulnerabilities)) {
                echo $type . "\n";
                foreach ($vulnerabilities as $vulnerability) {

                    if (!is_array($vulnerability)) {
                        print_r($vulnerabilities);
                        exit;
                    }

                    if (!is_array($vulnerability['codeSnippet'])) {
                        $vulnerability['codeSnippet'] = [$vulnerability['codeSnippet']];
                    }

                    foreach ($vulnerability['codeSnippet'] as $codeSnippet) {

                        if (!is_string($codeSnippet)) {
                            echo 'CODE SNIPPET NOT A STRING';
                            print_r($vulnerability);
                            continue;
                        }
                        $lineNum = calculateLineNumber($line, $source . '/' . $file, $codeSnippet);
                        if ($lineNum == 0)
                            $notFound++;
                        $vulnerability['vulnerability'] = '';
                        echo $vulnerability['vulnerability'] . ' - ' . $lineNum . ' vs. ' . $line . ' - ' . $type . "\n";

                        echo 'snippet: ' . $codeSnippet . "\n";
                        if ($type == 'pre')
                            echo 'truth: ' . getSnippetFromLineNumber($line, $source . '/' . $file);
                        echo $source . '/' . $file . "\n\n";
                        //    }

                        if ($type == 'pre') {
                            if (isset($flaggedPre[$lineNum]))
                                continue;
                            else
                                $flaggedPre[$lineNum] = 1;
                        } else {
                            if (isset($flaggedPost[$lineNum]))
                                continue;
                            else
                                $flaggedPost[$lineNum] = 1;
                        }
                        $record = [$cve, $repo, $commitHash, $file, $line, $truthSnippet, $lineNum, $codeSnippet, 'type', $vulnerability['description'], $vulnerability['cwe']];
                        fputcsv($resultsFile, $record, ',');
                        if ($type == 'pre') {
                            $preCountAll++;
                        }

                        if ($lineNum == $line) {
                            if ($type == 'pre')
                                $preCount++;
                            else
                                $postCount++;
                            fputcsv($resultsFile2, $record, ',');
                        }

                    }
                }
            }
        }

        global $time, $line;
        $promptLog = $post;
        $promptLog['TYPE'] = $type;
        $promptLog['CVE'] = $cve;
        $promptLog['line'] = $line;
        $promptLog['prompt'] = $prompt;
        $promptLog['messages'][1] = $source . '/' . $file;
        $promptLog['messages'][] = $reply;
        file_put_contents('logs/' . $time . '.txt', print_r($promptLog, true), FILE_APPEND);
        return true;
    } else {
        if ($type == 'post') {
            global $postNo;
            $postNo++;
        }

    }

    global $time, $line;
    $promptLog = $post;
    $promptLog['TYPE'] = $type;
    $promptLog['CVE'] = $cve;
    $promptLog['line'] = $line;
    $promptLog['prompt'] = $prompt;
    $promptLog['messages'][1] = $source . '/' . $file;
    $promptLog['messages'][] = $reply;
    file_put_contents('logs/' . $time . '.txt', print_r($promptLog, true), FILE_APPEND);
    return true;
}

function addChainOfThoughtPrompts($post, $template)
{
    $prompt1 = "Are there any security vulnerabilities in the code? Answer yes or no. Here is the code: ";
    $prompt2 = 'Find the security vulnerabilities in the code. Give a very brief description of each vulnerability and show the code snippet or lines of code with the vulnerability. When showing code, use the exact same formatting and line endings as the original code and include the full snippet.';
    $pathTraversal = "var color = document.getElementById('color').value;
    var path = document.getElementById('path').value;
fs.writeFileSync(path, 'Hello World!'); ";


    $post['messages'][] = ['role' => 'user', 'content' => $prompt1 . "\n" . $pathTraversal];
    $post['messages'][] = ['role' => 'assistant', 'content' => 'Yes.'];

    $post['messages'][] = ['role' => 'user', 'content' => $prompt2];
    $traversalResponse = "1. Relative path traversal: External input is used without sanitization to construct a pathname, which could resolve to a location outside that directory.";
    $traversalResponse .= "\n ```javascript \n
    fs.writeFileSync(pathname, 'Hello World!'); ```";
    $post['messages'][] = ['role' => 'assistant', 'content' => $traversalResponse];

    $post['messages'][] = ['role' => 'user', 'content' => 'Reformat your response in JSON format like this and determine the Common Weakness Enumeration or CWE for each vulnerability: ' . $template];

    $exampleResponse = '{ "vulnerabilities" :[ {"description": "Relative path traversal: External input is used without sanitization to construct a pathname, which could resolve to a location outside that directory.", "codeSnippet":"fs.writeFileSync(pathname, \'Hello World!\');", "cwe":"CWE-23"} ] };';
    $post['messages'][] = ['role' => 'assistant', 'content' => $exampleResponse];

    $pathTraversalFixed = "var path = document.getElementById('path').value;
path = path.normalize(path);
fs.writeFileSync(path, 'Hello World!');";
    $post['messages'][] = ['role' => 'user', 'content' => $prompt1 . "\n" . $pathTraversalFixed];
    $post['messages'][] = ['role' => 'assistant', 'content' => 'No.'];

    $XSS = '  var query = document.getElementById("searchBox").value;
              var resultsDiv=document.getElementById("results");
              resultsDiv.innerHTML = "Search results for:" + query;';

    $post['messages'][] = ['role' => 'user', 'content' => $prompt1 . "\n" . $XSS];
    $post['messages'][] = ['role' => 'assistant', 'content' => 'Yes'];
    $post['messages'][] = ['role' => 'user', 'content' => $prompt2];
    $XSSresponse = "1. Cross site scripting (XSS): The user input for search term is directly added to the DOM without being sanitized or encoded";
    $XSSresponse .= "\n ```javascript \n " . 'resultsDiv.innerHTML = "Search results for:" + query;' . " ```";
    $post['messages'][] = ['role' => 'assistant', 'content' => $XSSresponse];
    $exampleResponse = '{ "vulnerabilities" :[ {"description": "The user input for search term is directly added to the DOM without being sanitized or encoded", "codeSnippet":"resultsDiv.innerHTML = \"Search results for:\" + query;", "cwe":"CWE-79"} ] };';
    $post['messages'][] = ['role' => 'assistant', 'content' => $exampleResponse];

    return $post;
}


function runPromptAndProcessResponse($ch, $post, $secondTry = false, $recordError = false)
{
    global $cve, $file;
    $JSONpost = json_encode($post);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $JSONpost);
    $result = curl_exec($ch);
    $result = json_decode($result);
    if (!empty($result->choices[0]->message->content))
        return $result->choices[0]->message->content;
    else if (!empty($result->error) && $result->error->code == 'context_length_exceeded') {
        $post['error'] = $result->error->code;
        echo $result->error->message;
        addError(['cve' => $cve, 'file' => $file, 'error' => $result->error->code]);
        return false;
    } else if (!empty($result->error) && $result->error->code == 'rate_limit_exceeded') {
        if (!$secondTry) {
            echo $result->error->message;
            $seconds = 10;
            //extract how long we need to wait for from the error message and round up
            if (preg_match('#(\d+).\d+s#', $result->error->message, $matches)) {
                $seconds = $matches[1] + 2;
            }
            sleep($seconds);
            runPromptAndProcessResponse($ch, $post, true, $recordError);
        }
    } else {
        if (!$secondTry) {
            runPromptAndProcessResponse($ch, $post, true, $recordError);
        } else
            echo $result->error->message;
    }
    if ($recordError) {
        addError(['cve' => $cve, 'file' => $file, 'error' => $result->error->code]);
        $post['error'] = $result->error->code;
    }
    return false;
}

/**
 * @param $code - Code to be formatted
 * GPT sometimes returns code in the following form so we have to strip it out:
 *    ```javascript
 *       var code = '';
 *    ```
 */
function formatCode($code)
{
    if (strpos($code, '```')) {
        $code = substr($code, strpos($code, "\n")); //remove first line
        $code = str_replace('```', '', $code); //remove characters from end
    }
    return $code;
}

function addError($error)
{
    global $errors;
    if (!isset($errors[$error['cve']])) {
        $errors[$error['cve']] = $error;
    }
}

function removeComments($fileContent)
{
    return preg_replace("/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/m", "$1", $fileContent);
}

function getResponse($jsonResponse)
{
    $result = json_decode($jsonResponse);
    if (!empty($result->choices[0]->message->content))
        return $result->choices[0]->message->content;
}

// Prompts below are from early tests and are no longer used //

function prompt2($file)
{
    return 'Scan the code and find any security vulnerabilities in the code. Indicate how many vulnerabilities were found, if any. If there are any vulnerabilities, indicate the lines of code with the vulnerability and provide a very brief explanation why it is vulnerable.  
If the vulnerability is related to a Common Weaknesses enumeration (CWE), indicate which ones. For reference, here is a link with some descriptions and examples of Common weaknesses enumerations: https://cwe.mitre.org/data/slices/1350.html
Answer in JSON format.
Here is the code to analyze: ' . $file;
}


function prompt3($file)
{
    return 'Scan the code below and find any security vulnerabilities. If there are no vulnerabilities in the code, respond that the vulnerability_count is 0. 
    Answer in JSON format.
    Here is the code to analyze: ' . $file;
}


function prompt1($file)
{
    return "Are there any vulnerabilities in the code below? If there are any vulnerabilities:
1. Show the line(s) of code with the vulnerability.
2. Indicate which Common Weaknesses enumerations (CWE) the vulnerability is related to
3. Indicate the vulnerability type
4. Give a very brief explanation of why the code is vulnerable. 
If there are no vulnerabilities, leave the fields blank and set the vulnerability_count to 0. 
 Answer in JSON format. 
 Here is the code to analyze: " . $file;
}

function responseTemplate()
{
    //  $post['response_format'] = ['type' => 'json_object'];
    //  $post['functions'] = responseTemplate2_v1();
    return [
        ['name' => 'detect_vulnerabilities', 'parameters' => [
            'type' => 'object',
            'properties' => [
                'vulnerability_count' => ['type' => 'integer', 'description' => 'How many vulnerabilities were found'],
                'vulnerabilities' => ['type' => 'object',
                    'properties' => [
                        'code_snippet' => ['type' => 'string', 'description' => 'Line of code with the vulnerability'],
                        'type' => ['type' => 'string', 'description' => 'The type of vulnerability'],
                        'reason' => ['type' => 'string', 'description' => 'Brief explanation of the vulnerability'],
                        'CWE' => ['type' => 'string', 'description' => 'The Common weaknesses enumeration or CWE of the vulnerability']
                    ]
                ]
            ]
        ]
        ]
    ];
}

function responseTemplate2_v1()
{
    return [
        ['name' => 'detect_vulnerabilities', 'parameters' => [
            'type' => 'object', 'description' => 'List each type of vulnerability found in the code.',
            'properties' => [
                //  'vulnerability_count' => ['type' => 'integer', 'description' => 'How many vulnerabilities were found'],
                'vulnerabilities' => ['type' => 'object',
                    'properties' => [
                        //      'code_snippet' => ['type' => 'string', 'description' => 'Line of code with the vulnerability'],
                        'type' => ['type' => 'string', 'description' => 'The type of vulnerability'],
                    ]
                ]
            ]
        ]
        ]
    ];
}



